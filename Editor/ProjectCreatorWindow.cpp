#include "stdafx.h"
#include "ProjectCreatorWindow.h"

using namespace wi::ecs;
using namespace wi::scene;

void ProjectCreatorWindow::Create(EditorComponent* _editor)
{
	editor = _editor;
	control_size = 30;

	wi::gui::Window::Create("Project Creator");

	infoLabel.Create("projectCreatorInfo");
	infoLabel.SetFitTextEnabled(true);
	infoLabel.SetText("Here you can create a new Wicked Engine application project. It will create a new folder with the project name, and set up an executable, lua script startup, custom icon and thumbnail.");
	AddWidget(&infoLabel);

	projectNameInput.Create("projectName");
	projectNameInput.SetText("");
	projectNameInput.SetDescription("Name: ");
	projectNameInput.SetCancelInputEnabled(false);
	AddWidget(&projectNameInput);

	iconButton.Create("projectIcon");
	iconButton.SetText("");
	iconButton.SetDescription("Icon: ");
	iconButton.SetSize(XMFLOAT2(128, 128));
	iconButton.SetTooltip("The icon will be used for the executable icon.");
	iconButton.OnClick([this](wi::gui::EventArgs args) {
		if (iconResource.IsValid())
		{
			iconResource = {};
			iconName = {};
			iconButton.SetImage(iconResource);
		}
		else
		{
			wi::helper::FileDialogParams params;
			params.type = wi::helper::FileDialogParams::OPEN;
			params.description = "Texture";
			params.extensions = wi::resourcemanager::GetSupportedImageExtensions();
			wi::helper::FileDialog(params, [this](std::string fileName) {
				wi::eventhandler::Subscribe_Once(wi::eventhandler::EVENT_THREAD_SAFE_POINT, [=](uint64_t userdata) {
					wi::Resource res = wi::resourcemanager::Load(fileName);
					if (!res.IsValid())
						return;
					iconResource.SetTexture(editor->CreateThumbnail(res.GetTexture(), 128, 128));
					iconName = fileName;
					iconButton.SetImage(iconResource);
				});
			});
		}
	});
	AddWidget(&iconButton);

	thumbnailButton.Create("projectThumbnail");
	thumbnailButton.SetText("");
	thumbnailButton.SetDescription("Thumbnail: ");
	thumbnailButton.SetSize(XMFLOAT2(480 * 0.5f, 270 * 0.5f));
	thumbnailButton.SetTooltip("The thumbnail will be used for displaying the project in the editor.");
	thumbnailButton.OnClick([this](wi::gui::EventArgs args) {
		if (thumbnailResource.IsValid())
		{
			thumbnailResource = {};
			thumbnailName = {};
			thumbnailButton.SetImage(thumbnailResource);
		}
		else
		{
			wi::helper::FileDialogParams params;
			params.type = wi::helper::FileDialogParams::OPEN;
			params.description = "Texture";
			params.extensions = wi::resourcemanager::GetSupportedImageExtensions();
			wi::helper::FileDialog(params, [this](std::string fileName) {
				wi::eventhandler::Subscribe_Once(wi::eventhandler::EVENT_THREAD_SAFE_POINT, [=](uint64_t userdata) {
					wi::Resource res = wi::resourcemanager::Load(fileName);
					if (!res.IsValid())
						return;
					thumbnailResource.SetTexture(editor->CreateThumbnail(res.GetTexture(), 480, 270));
					thumbnailName = fileName;
					thumbnailButton.SetImage(thumbnailResource);
				});
			});
		}
	});
	AddWidget(&thumbnailButton);

	createButton.Create("projectCreate");
	createButton.SetText("Select folder and create project");
	createButton.OnClick([this](wi::gui::EventArgs args) {
		if (projectNameInput.GetText().empty())
		{
			wi::helper::messageBox("Application name must be provided first!");
			return;
		}
		std::string folder = wi::helper::FolderDialog("Select location where project folder will be created.");
		if (folder.empty())
			return;
		std::string name = projectNameInput.GetText();
		while (name.length() > 250)
		{
			// The name cannot be longer than 256 - ".lua", so cut from the end of it
			//	It is specifically because I will later overwrite a reserved 256-long string inside the executable
			name.pop_back();
		}
		std::string directory = folder + "/" + name + "/";
		wi::helper::DirectoryCreate(directory);

		static const std::string script = R"(
-- This script was generated by Wicked Editor Project Creator
backlog_post("Hello World!")
)";

		std::string scriptfilename = name + ".lua";
		wi::helper::FileWrite(directory + scriptfilename, (const uint8_t*)script.data(), script.size());
		if (iconResource.IsValid())
		{
			wi::helper::saveTextureToFile(iconResource.GetTexture(), directory + "icon.png");
			wi::helper::saveTextureToFile(iconResource.GetTexture(), directory + "icon.h");
		}
		if (thumbnailResource.IsValid())
		{
			wi::helper::saveTextureToFile(thumbnailResource.GetTexture(), directory + "thumbnail.png");
		}
		std::string exepath_src = wi::helper::GetExecutablePath();
		std::string exepath_dst = directory + name + ".exe";
		if (wi::helper::FileCopy(exepath_src, exepath_dst))
		{
			wi::vector<uint8_t> exedata;
			if (wi::helper::FileRead(exepath_dst, exedata))
			{
				// string replacement in the executable:
				{
					auto it = std::search(exedata.begin(), exedata.end(), editor->main->rewriteable_startup_script_text.begin(), editor->main->rewriteable_startup_script_text.end());
					if (it != exedata.end())
					{
						wi::vector<uint8_t> replacement(scriptfilename.length() + 1);
						std::copy(scriptfilename.begin(), scriptfilename.end(), replacement.begin());
						std::copy(replacement.begin(), replacement.end(), it);
					}
				}

				// icon replacement in the Win32 executable:
				if (iconResource.IsValid())
				{
					wi::graphics::Texture tex = iconResource.GetTexture();

					struct ICONDIR
					{
						uint16_t idReserved;   // Reserved (must be 0)
						uint16_t idType;       // Resource Type (1 for icon)
						uint16_t idCount;      // Number of images
					};
					struct ICONDIRENTRY
					{
						uint8_t  bWidth;       // Width, in pixels
						uint8_t  bHeight;      // Height, in pixels
						uint8_t  bColorCount;  // Number of colors (0 if >= 8bpp)
						uint8_t  bReserved;    // Reserved (must be 0)
						uint16_t wPlanes;      // Color Planes
						uint16_t wBitCount;    // Bits per pixel
						uint32_t dwBytesInRes; // Size of image data
						uint32_t dwImageOffset;// Offset to image data
					};
					struct BITMAPINFOHEADER
					{
						uint32_t biSize;       // Size of this header
						int32_t  biWidth;      // Width in pixels
						int32_t  biHeight;     // Height in pixels (doubled for icon)
						uint16_t biPlanes;     // Number of color planes
						uint16_t biBitCount;   // Bits per pixel
						uint32_t biCompression;// Compression method
						uint32_t biSizeImage;  // Size of image data
						int32_t  biXPelsPerMeter; // Horizontal resolution
						int32_t  biYPelsPerMeter; // Vertical resolution
						uint32_t biClrUsed;    // Colors used
						uint32_t biClrImportant; // Important colors
					};

					const uint32_t pixelCount = tex.desc.width * tex.desc.height;
					const uint32_t rgbDataSize = pixelCount * 4; // 32-bit RGBA
					const uint32_t maskSize = ((tex.desc.width + 7) / 8) * tex.desc.height; // 1-bit mask, padded to byte
					const uint32_t bmpInfoHeaderSize = sizeof(BITMAPINFOHEADER);
					const uint32_t iconDirSize = sizeof(ICONDIR);
					const uint32_t iconDirEntrySize = sizeof(ICONDIRENTRY);
					const uint32_t imageDataSize = bmpInfoHeaderSize + rgbDataSize + maskSize;

					BITMAPINFOHEADER bmpHeader = {
						bmpInfoHeaderSize, // Size of header
						int32_t(tex.desc.width), // Width
						int32_t(tex.desc.height * 2), // Height (doubled for XOR + AND mask)
						1, // Planes
						32, // Bits per pixel
						0, // No compression
						rgbDataSize + maskSize, // Image size
						0, // X pixels per meter
						0, // Y pixels per meter
						0, // Colors used
						0  // Important colors
					};

					wi::vector<uint8_t> bmpvec(sizeof(bmpHeader));
					std::memcpy(bmpvec.data(), &bmpHeader, sizeof(bmpHeader));

					// searches for exact BMP header match:
					auto it = std::search(exedata.begin(), exedata.end(), bmpvec.begin(), bmpvec.end());
					if (it != exedata.end())
					{
						wi::vector<uint8_t> iconfiledata;
						if (wi::helper::saveTextureToMemoryFile(tex, "ico", iconfiledata))
						{
							// replace the BMP header and data part:
							std::copy(iconfiledata.begin() + sizeof(ICONDIR) + sizeof(ICONDIRENTRY), iconfiledata.end(), it);
						}
					}
				}

				// icon replacement in the Linux executable:
				if (iconResource.IsValid())
				{
					wi::graphics::Texture tex = iconResource.GetTexture();

					std::string match = "Wicked Editor Embedded Icon Data SDL";

					// searches for match string:
					auto it = std::search(exedata.begin(), exedata.end(), match.begin(), match.end());
					if (it != exedata.end())
					{
						wi::vector<uint8_t> iconfiledata;
						if (wi::helper::saveTextureToMemoryFile(tex, "raw", iconfiledata))
						{
							// replace the pixel data part:
							std::copy(iconfiledata.begin(), iconfiledata.end(), it + match.length() + 1);
						}
					}
				}

				wi::helper::FileWrite(exepath_dst, exedata.data(), exedata.size());
			}
		}
		editor->RegisterRecentlyUsed(directory + scriptfilename);
		wi::helper::OpenUrl(directory);
	});
	AddWidget(&createButton);

	SetVisible(false);
}

void ProjectCreatorWindow::ResizeLayout()
{
	wi::gui::Window::ResizeLayout();

	layout.margin_left = 60;

	layout.add_fullwidth(infoLabel);
	layout.add(projectNameInput);
	layout.add_right(iconButton);
	layout.add_right(thumbnailButton);

	layout.jump();

	layout.add_fullwidth(createButton);
}
